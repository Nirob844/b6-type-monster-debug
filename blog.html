<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Blog</title>

</head>

<body>
    <header>
        <ul>
            <li><a class="aaa" href="/index.html">Home</a></li>
            <li><a class="aaa" href="/blog.html">Blog</a></li>
        </ul>
    </header>
</body>
<main>
    <section>
        <div>
            <h2>Difference Between Local Storage, Session Storage. </h2>
            <p>
                localStorage and sessionStorage are relatively new APIs (meaning, not all legacy browsers will support
                them) and are near identical (both in APIs and capabilities) with the sole exception of persistence.
                sessionStorage (as the name suggests) is only available for the duration of the browser session (and is
                deleted when the tab or window is closed) - it does, however, survive page reloads (source DOM Storage
                guide - Mozilla Developer Network).

                Clearly, if the data you are storing needs to be available on an ongoing basis then localStorage is
                preferable to sessionStorage - although you should note both can be cleared by the user so you should
                not rely on the continuing existence of data in either case.

                localStorage and sessionStorage are perfect for persisting non-sensitive data needed within client
                scripts between pages (for example: preferences, scores in games). The data stored in localStorage and
                sessionStorage can easily be read or changed from within the client/browser so should not be relied upon
                for storage of sensitive or security-related data within applications.
            </p>
        </div>
        <div>
            <h2>Difference Between block scope, global scope </h2>
            <p>
                The variables defined outside of any function or curly brackets are known as global variables and have
                global scope. Global scope means that the variables can be accessed from any part of that program, any
                function or conditional state can access that variable. <br>
                Block scope is also a sub-type of local scope. The block scope can be defined as the scope of the
                variables inside the curly brackets {}. Now, these curly brackets can be of loops, or conditional
                statements, or something else. You are only allowed to refer to these variables from within the curly
                brackets {}.
            </p>
        </div>
        <h2>Event loop in JavaScript</h2>
        <p>
            The event loop is the secret behind JavaScript’s asynchronous programming. JS executes all operations on a
            single thread, but using a few smart data structures, it gives us the illusion of multi-threading. Let’s
            take a look at what happens on the back-end. <br>
            The call stack is responsible for keeping track of all the operations in line to be executed. Whenever a
            function is finished, it is popped from the stack. <br>
            The event queue is responsible for sending new functions to the stack for processing. It follows the queue
            data structure to maintain the correct sequence in which all operations should be sent for execution.
            <br>
            Whenever an async function is called, it is sent to a browser API. These are APIs built into the browser.
            Based on the command received from the call stack, the API starts its own single-threaded operation.

            An example of this is the setTimeout method. When a setTimeout operation is processed in the stack, it is
            sent to the corresponding API which waits till the specified time to send this operation back in for
            processing.

            Where does it send the operation? The event queue. Hence, we have a cyclic system for running async
            operations in JavaScript. The language itself is single-threaded, but the browser APIs act as separate
            threads.

            The event loop facilitates this process; it constantly checks whether or not the call stack is empty. If it
            is empty, new functions are added from the event queue. If it is not, then the current function call is
            processed.
        </p>
    </section>
</main>

</html>